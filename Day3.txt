Html的标签：1.行级标签： 宽高根据内容自动撑开，不可以设置宽高。多个标签可以显示在一行。a链接标签，b/strong加粗标签，small小字体标签，i斜体标签，label，span，sub，sup，textarea，big，em。2.块级标签： 宽度默认是100%，高度默认自动撑开，可以设置宽高。一行只能展示一个标签。div标签，h1-h6标题标签，from表单，header头部内容，footer页脚，table表格，ol有序列表，ul无序列表，dl自定义列表，li列表元素标签，iframe内联框架，nav导航，section文档标签。3.行内块标签：结合的行内和块级的优点，不仅可以对宽高属性值生效，还可以多个标签存在一行显示；img图片标签，input输入框标签。HTML中的input type属性有哪些，哪些是h5新增的？1.type属性常用的有button，表示按钮2.input的type属性还可以使用checkbox，表示复选框3. radio 单选框4. password 密码框5. text  文本框6. reset  重置按钮7. submit 重置按钮h5新增的input属性：HTML有哪些语义化标签：1、header标签；2、nav标签；3、footer标签；4、hgroup标签；5、section标签；6、article标签；7、aside标签；8、figure标签；9、time标签；10、address标签。常⽤的meta标签有哪些;charset，用来描述HTML文档的编码类型keywords，页面关键词description，页面描述refresh，页面重定向和刷新viewport，适配移动端，可以控制视口的大小和比例CSS有哪些选择器：一，简单选择器：    通用元素选择器    标签选择器    类选择器    id选择器二，属性选择器三，组合选择器四，伪类选择器五，伪元素选择器选择器的权重：继承 < 通配符选择器 < 标签选择器 < 类选择器 < id选择器 < 行内（内联）样式 < !important内联 > ID选择器 > 类选择器 > 标签选择器。优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：
	1. 如果存在内联样式，那么 A = 1, 否则 A = 0;
	2. B 的值等于 ID选择器 出现的次数;
	3. C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;
	4. D 的值等于 标签选择器 和 伪元素 出现的总次数 。

比较规则是: 从左往右依次进行比较 ，较大者胜出，如果相等，则继续往右移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的页面布局常用的方法：浮动、定位、flex、grid网格布局、栅格系统布局浮动布局的缺点：1. 浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷盒子模型：盒子模型顾名思义就是一个盒子就是一个矩形，英文名box model盒子模型主要包含内容区、边框、内边距、外边距 盒模型一共分为两种：标准盒模型和怪异盒模型，只要在代码头部添加了doctype声明，浏览器就会默认该页面为标准盒模型通过box-sizing属性设置盒模型： box-sizing:content-box(标准盒模型)\border-box(怪异盒模型)标准盒模型： 一个盒子的总宽度= width + padding(左右) + border(左右)+ margin(左右)怪异盒模型： 一个盒子的总宽度= width + margin(左右) （即width已经包含了padding和border值）BFCBFC全称Block Formatting Context,名为块级格式化上下文。 简单来说BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。 如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。触发BFC的条件
	* 根元素或包含根元素的元素
	* 浮动元素 float ＝ left | right 或 inherit**（≠ none）**
	* 绝对定位元素 position ＝ absolute 或 fixed
	* display ＝ inline-block | flex | inline-flex | table-cell 或 table-caption
	* overflow ＝ hidden | auto 或 scroll (≠ visible)

BFC特性
	* BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。
	* 盒子从顶端开始垂直地一个接一个地排列，盒子之间垂直的间距是由 margin 决定的。
	* 在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。
	* BFC 区域不会和 float box 发生重叠。
	* BFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了。

清除浮动的方法：1、利用clear样式.textDiv {color: blue;border: 2px solid blue;clear: left;}<div class="topDiv"><div class="textDiv">...</div><div class="floatDiv">float left</div></div><div class="bottomDiv">...</div>2、父元素结束标签之前插入清除浮动的块级元素(额外标签法)HTML结构如下，在有浮动的父级元素的末尾插入了一个没有内容的块级元素div：.clearfix {/* 清除左右两侧浮动的影响 */clear:both;}<!-- 父子级标签，子级浮动，父级没有高度，后面的标准流盒子会受影响，显示到上面的位置 --><div class="top"><div class="left"></div><div class="right"></div><div class="clearfix"></div></div><div class="bottom"></div>3、 利用伪元素（clearfix）(单伪元素标签法)/* 单伪元素清除浮动 和 额外标签法原理是一样的 */.clearfix::after {content: '';/* 伪元素添加的标签是行内的，要求块 */display: block;clear: both;/* 补充代码：网页中看不到伪元素 (无影响)*/height: 0;visibility: hidden;}<!-- 父子级标签，子级浮动，父级没有高度，后面的标准流盒子会受影响，显示到上面的位置 --><div class="top clearfix"><div class="left"></div><div class="right"></div><!-- 通过css 添加标签 --></div><div class="bottom"></div>4、双伪元素标签法/* .clearfix::before 作用：解决外边距塌陷问题 外边距塌陷：父子标签，都是块级，子级加margin会影响父级的位置 *//* 清除浮动 */.clearfix::before,.clearfix::after {content: '';display: table;}/* 真正清除浮动的标签 */.clearfix::after {clear: both;}5、利用overflow清除浮动.topDiv {width: 500px;padding: 4px;border: 2px solid black;// 区别在这里overflow: auto;}<div class="topDiv"><div class="floatDiv">float left</div><div class="textDiv">...</div></div><div class="bottomDiv">...</div>css实现水平垂直居中的方法：1、absolute + 负margin绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示，但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示。为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了。.wp {position: relative;}.box {position: absolute;;top: 50%;left: 50%;margin-left: -50px;margin-top: -50px;}2、absolute + margin auto这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了。这种方法兼容性也很好，缺点是需要知道子元素的宽高。.wp {position: relative;}.box {position: absolute;;top: 0;left: 0;right: 0;bottom: 0;margin: auto;}3、absolute + calc这种方式也要求居中元素的宽高必须固定。既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了。这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高。.wp {position: relative;}.box {position: absolute;;top: calc(50% - 50px);left: calc(50% - 50px);}4、absolute + transform还是绝对定位，但这个方法不需要子元素固定宽高。修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲translate设置为-50%，就可以做到居中了。.wp {position: relative;}.box {position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);}5、flex.wp {display: flex;justify-content: center;align-items: center;}6、grid.wp {display: grid;}.box {align-self: center;justify-self: center;}CSS隐藏页面元素的方法：display:none ： display翻译成中文是显示、展览的意思；将display的属性改为none可以实现元素的隐藏，元素和盒子模型也不生成，被隐藏的元素不占位置，看不见摸不着，它会导致浏览器的重排和重绘。visibility:hidden： visibility翻译成中文是能见、可见性的意思；hidden翻译成中文的是隐藏、不易察觉的意思。将visibility的属性改成hidden可以实现元素的隐藏，和display:none的区别是它占位置，看不见但是摸得着，所以它只会导致浏览器重绘而不会重排。opacity:0： opacity翻译成中文是透明度、不透明的意思；将opacity的属性改成0那就是透明度等于0看不见元素，但是这种方法也是只能隐藏看不见元素，和visibility:hidden一样，元素依然存在页面中。position： 利用定位将元素的top和left值设为足够大的负数，使它移出屏幕在屏幕上看不见。overflow:hidden： overflow翻译成中文是漫出、溢出的意思；将overflow的属性设置hidden可以实现元素隐藏，但是这个是超出盒子的部分隐藏，有局限性。px、rpx、em、rem、vw、vh各种像素单位的区别：px：px就是 pixel的缩写，意味像素。px就是一张图片最小的一个点，一张位图就是无数个这样的点构成的，是web开发中最常用的像素单位。rpx：由微信小程序官方推出的新单位，适用于移动端的 uni-app或者微信小程序的开发。可以根据屏幕宽度进行自适应，1rpx实际上等于相对于屏幕宽度的1物理像素。在设计时可以将1px约等于2rpx。em：相对单位，参照物是父元素的 font-size字体大小，具有继承的特点。如果自身定义了 font-size属性那么就会按照自身来计算，都没有设置的话，就会按照当前所有浏览器或者设备的默认文字大小来计算调整。一般来说浏览器的默认字体大小为16px，一个完整的页面内，可能每个模块的 em默认值都不想同。rem：css3中推出的新单位。相对于根元素（html）设置的 font-size属性进行调整，而不会像 em那样依赖于父元素的字体大小而造成页面文字大小不相同的混乱局面。vw：同样是css3中推出的新单位，是 viewpoint width的缩写，意为视窗宽度。视窗宽度1vw等于是窗宽度的1%。也就是说，如果当前开发浏览器或者设备的宽度为1280px，那么1vw就等于12.8px。在开发设计的过程中，100vw才能真正占据当前屏幕宽度的100%。vh：和vw同理，是css3中推出的新单位，是 viewpoint height的缩写，意为视窗高度。视窗高度1vh等于是窗高度的1%。计算及使用都与vw相同，伪类与伪元素选择器的区别：伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如：当用户悬停在指定元素时，可以通过:hover来描述这个元素的状态，虽然它和一般css相似，可以为已有元素添加样式，但是它只有处于DOM树无法描述的状态下才能为元素添加样式，所以称为伪类。伪元素：用于创建一些不在DOM树中的元素，并为其添加样式。例如，我们可以通过:before来在一个元素之前添加一些文本，并为这些文本添加样式，虽然用户可以看见这些文本，但是它实际上并不在DOM文档中。遍历数组的几种方法：1.forEach: 遍历数组,把数组的每一项交给回调函数来处理,不能使用break和continue让他停下来,没有返回值    let arr = [10,20,30,40,50];    arr.forEach((item,index)=>{           //item是数组遍历出来的一个个的项, index是项对应的下标           console.log(item,index);})2.map: 遍历数组不会停下来返回的是一个数组,数组的元素return回去的值.let arr = [10,11,12,13,14,15];let result = arr.map((item,index)=>{    //item,index是遍历出来的每一项和对应的下标    //console.log(item,index);    //return 100;    return item * 2;;});console.log(result);3.filter: 遍历数组,不能使用break和continue停下来,有返回值.返回时一个数组, 数组的元素是当前为true的那一项let arr = [10,11,44,33,22,56,31,21]let result = arr.filter((item,index)=>{    //item和index是遍历出来的每一项和对应的下标    //console.log(item,index);    return item >= 18;});console.log(result);4.some: 判断数组中是否有符合条件的元素,如果有就返回true,没有就返回falselet arr = [10,20,30,40,50];let res = arr.some((item,index)=>{    return item > 400;});console.log(res);5.every: 数组中的所有元素符合条件才返回true, 否则返回falselet arr = [10,20,30,40,50];let res = arr.every((item,index)=>{    return item > 0;});console.log(res);bind 与 call/apply 的区别是什么1)执行方式不同： call和apply是改变后页面加载之后就立即执行，是同步代码。                          bind是异步代码，改变后不会立即执行；而是返回一个新的函数。2)传参方式不同： call和bind传参是一个一个逐一传入，不能使用剩余参数的方式传参。                              apply可以使用数组的方式传入的，只要是数组方式就可以使用剩余参数的方式传入。3)修改this的性质不同：  call、apply只是临时的修改一次，也就是call和apply方法的那一次；当再次调用原函数的时候，它的指向还是原来的指向。 bind是永久修改函数this指向，但是它修改的不是原来的函数；而是返回一个修改过后新的函数，此函数的this永远被改变了，绑定了就修改不了。什么是闭包，闭包的应用有哪些地方:闭包就是函数中的函数、里面的函数可以访问外面函数的变量、外面的变量是这个内部函数中的一部分。闭包的形成条件：
	1. 函数嵌套
	2. 内部函数访问外部函数的变量
	3. 内部函数被外部引用

闭包的应用场景：函数防抖回调
